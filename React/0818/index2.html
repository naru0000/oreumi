<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Redux: 왜 이렇게 사용해야 하는가?</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Malgun Gothic', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      overflow: hidden;
    }

    .slideshow-container {
      position: relative;
      width: 100%;
      height: 100vh;
    }

    .slide {
      display: none;
      padding: 40px 60px;
      text-align: center;
      height: 100vh;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .slide.active {
      display: flex;
    }

    .slide h1 {
      font-size: 2.8em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      color: #fff;
    }

    .slide h2 {
      font-size: 2.2em;
      margin-bottom: 25px;
      color: #FFD700;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
    }

    .slide h3 {
      font-size: 1.8em;
      margin-bottom: 15px;
      color: #87CEEB;
    }

    .slide p {
      font-size: 1.3em;
      line-height: 1.6;
      margin-bottom: 15px;
      max-width: 900px;
    }

    .slide ul {
      font-size: 1.2em;
      line-height: 1.8;
      text-align: left;
      max-width: 800px;
      margin: 20px 0;
    }

    .slide li {
      margin-bottom: 10px;
      padding-left: 20px;
      position: relative;
    }

    .slide li:before {
      content: "▶";
      position: absolute;
      left: 0;
      color: #FFD700;
    }

    .code-block {
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      text-align: left;
      margin: 15px 0;
      max-width: 850px;
      overflow-x: auto;
      border-left: 4px solid #FFD700;
    }

    .flow-diagram {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin: 25px 0;
      flex-wrap: wrap;
    }

    .flow-box {
      background: rgba(255, 255, 255, 0.15);
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 1.1em;
      min-width: 120px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .arrow {
      font-size: 1.5em;
      color: #FFD700;
      font-weight: bold;
    }

    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
      max-width: 900px;
    }

    .wrong {
      background: rgba(255, 0, 0, 0.2);
      padding: 20px;
      border-radius: 10px;
      border-left: 5px solid #ff4444;
    }

    .correct {
      background: rgba(0, 255, 0, 0.2);
      padding: 20px;
      border-radius: 10px;
      border-left: 5px solid #44ff44;
    }

    .highlight {
      background: rgba(255, 235, 59, 0.3);
      padding: 3px 8px;
      border-radius: 5px;
      color: #FFD700;
      font-weight: bold;
    }

    .big-emoji {
      font-size: 3em;
      margin: 20px 0;
    }

    .navigation {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .nav-btn {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
    }

    .nav-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.05);
    }

    .nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .slide-counter {
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 15px;
      border-radius: 15px;
      font-size: 0.9em;
    }

    .vertical-flow {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .step-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 1.1em;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .quiz-box {
      background: rgba(255, 193, 7, 0.2);
      padding: 20px;
      border-radius: 10px;
      border: 2px solid #FFD700;
      margin: 20px 0;
    }

    .three-stage {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin: 20px 0;
    }

    .stage-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(50px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .slide.active * {
      animation: slideIn 0.6s ease-out;
    }
  </style>
</head>

<body>
  <div class="slideshow-container">
    <!-- 슬라이드 1: 제목 -->
    <div class="slide active">
      <h1>📺 Redux: 왜 이렇게 사용해야 하는가?</h1>
      <p style="font-size: 1.5em; color: #87CEEB; margin-top: 30px;">
        TV 리모컨으로 이해하는 Redux의 존재 이유
      </p>
      <div class="big-emoji">🤔💭</div>
    </div>

    <!-- 슬라이드 2: Redux를 TV로 이해하기 -->
    <div class="slide">
      <h2>Redux를 TV로 이해하기</h2>
      <h3>📺 TV 시청 과정 = Redux 과정</h3>

      <div class="comparison">
        <div style="text-align: center;">
          <h3>🏠 현실: TV 시청</h3>
          <div class="vertical-flow">
            <div class="step-box">👨‍💼 사용자</div>
            <div class="arrow">↓</div>
            <div class="step-box">🔘 리모컨 버튼</div>
            <div class="arrow">↓</div>
            <div class="step-box">📡 리모컨 신호</div>
            <div class="arrow">↓</div>
            <div class="step-box">⚙️ TV 내부 회로</div>
            <div class="arrow">↓</div>
            <div class="step-box">📦 TV 상태 변경</div>
            <div class="arrow">↓</div>
            <div class="step-box">📺 화면 업데이트</div>
          </div>
        </div>
        <div style="text-align: center;">
          <h3>💻 Redux</h3>
          <div class="vertical-flow">
            <div class="step-box">👨‍💼 사용자</div>
            <div class="arrow">↓</div>
            <div class="step-box">🔘 버튼 클릭</div>
            <div class="arrow">↓</div>
            <div class="step-box">📡 Action (신호)</div>
            <div class="arrow">↓</div>
            <div class="step-box">⚙️ Reducer (회로)</div>
            <div class="arrow">↓</div>
            <div class="step-box">📦 Store (TV 상태)</div>
            <div class="arrow">↓</div>
            <div class="step-box">📺 컴포넌트 업데이트</div>
          </div>
        </div>
      </div>

      <div class="quiz-box">
        <p style="font-size: 1.2em;">
          <strong>Redux = TV 리모컨 시스템!</strong>
        </p>
      </div>
    </div>

    <!-- 슬라이드 3: TV 구성 요소들 -->
    <div class="slide">
      <h2>TV 시스템의 구성 요소들</h2>
      <h3>각 부분이 하는 일</h3>

      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; margin: 30px 0;">
        <div class="flow-box">
          <h3>📦 TV 본체 = Store</h3>
          <p>• 현재 채널, 볼륨 등 모든 상태 저장<br />
            • 집에 TV 하나만 있듯이 Store도 하나</p>
        </div>
        <div class="flow-box">
          <h3>🔘 리모컨 버튼 = Action</h3>
          <p>• "7번 채널로 바꿔줘"<br />
            • "볼륨 올려줘"<br />
            • 명령서 역할</p>
        </div>
        <div class="flow-box">
          <h3>⚙️ TV 내부 회로 = Reducer</h3>
          <p>• 리모컨 신호 받아서 실제 처리<br />
            • "7번 버튼 눌렸네? 채널 바꿔야지"<br />
            • 똑똑한 처리 시스템</p>
        </div>
        <div class="flow-box">
          <h3>📡 신호 전송 = Dispatch</h3>
          <p>• 리모컨 버튼 누르는 행위<br />
            • 신호를 TV에게 전달<br />
            • "전송!"</p>
        </div>
      </div>
    </div>

    <!-- 슬라이드 4: 실제 TV 작동 과정 -->
    <div class="slide">
      <h2>실제 TV 작동 과정</h2>
      <h3>"7번 채널로 바꿔줘!" 요청 처리</h3>

      <div class="vertical-flow">
        <div class="step-box" style="background: rgba(255,193,7,0.3);">
          <strong>1. 사용자:</strong> "7번 채널 보고 싶어!"
        </div>
        <div class="arrow">↓</div>
        <div class="step-box" style="background: rgba(33,150,243,0.3);">
          <strong>2. 리모컨 버튼:</strong> 7번 버튼 클릭
        </div>
        <div class="arrow">↓</div>
        <div class="step-box" style="background: rgba(156,39,176,0.3);">
          <strong>3. 신호 전송:</strong> "CHANGE_CHANNEL_TO_7" 신호 발송
        </div>
        <div class="arrow">↓</div>
        <div class="step-box" style="background: rgba(255,87,34,0.3);">
          <strong>4. TV 내부 회로:</strong> "7번 신호네? 채널 바꿔야지"
        </div>
        <div class="arrow">↓</div>
        <div class="step-box" style="background: rgba(76,175,80,0.3);">
          <strong>5. TV 상태 변경:</strong> 채널 = 7 저장
        </div>
        <div class="arrow">↓</div>
        <div class="step-box" style="background: rgba(96,125,139,0.3);">
          <strong>6. 화면 업데이트:</strong> 7번 채널 방송 나옴
        </div>
      </div>

      <p style="margin-top: 20px; font-size: 1.3em; color: #FFD700;">
        <strong>이게 바로 Redux 플로우!</strong>
      </p>
    </div>

    <!-- 슬라이드 5: TV 코드로 보기 -->
    <div class="slide">
      <h2>TV를 코드로 표현하면?</h2>

      <div class="code-block">
        // 📦 TV 상태 (Store)
        const tvState = {
        power: true,
        channel: 5,
        volume: 15
        };

        // 🔘 리모컨 버튼 (Action)
        const pressChannel7Button = () => ({
        type: 'CHANGE_CHANNEL',
        payload: 7
        });

        // ⚙️ TV 내부 회로 (Reducer)
        const tvReducer = (currentState, remoteSignal) => {
        if (remoteSignal.type === 'CHANGE_CHANNEL') {
        return {
        ...currentState, // 기존 설정 유지 (전원, 볼륨)
        channel: remoteSignal.payload // 채널만 변경
        };
        }
        return currentState;
        };

        // 📡 신호 전송 (Dispatch)
        dispatch(pressChannel7Button());
        // 결과: { power: true, channel: 7, volume: 15 }
      </div>

      <p style="margin-top: 20px; font-size: 1.3em;">
        <span class="highlight">TV 비유로 이해하면 Redux가 쉬워집니다!</span>
      </p>
    </div>

    <!-- 슬라이드 4: 데이터 플로우 문제점 -->
    <div class="slide">
      <h2>1️⃣ 데이터 플로우: 왜 한 방향으로만?</h2>
      <h3>❓ Why: 왜 Redux는 단방향 플로우를 강요하나?</h3>

      <div class="comparison">
        <div class="wrong">
          <h3>❌ 양방향의 문제점</h3>
          <div class="code-block">
            // 양방향 데이터 플로우 (위험!)
            컴포넌트 A ⟷ 상태 ⟷ 컴포넌트 B
            ↕️ ↕️
            컴포넌트 C ⟷ 상태 ⟷ 컴포넌트 D

            // 누가 언제 상태를 바꿨는지 추적 불가능!
          </div>
        </div>
        <div class="correct">
          <h3>✅ Redux의 단방향 플로우</h3>
          <div class="code-block">
            Action → Reducer → Store → View
            ↑ ↓
            ←←←←← 한 방향으로만! ←←←←←
          </div>
        </div>
      </div>

      <p style="font-size: 1.4em; margin-top: 20px; color: #FFD700;">
        <strong>Why 이렇게?</strong> 상태 변화를 예측 가능하게 만들기 위해!
      </p>
    </div>

    <!-- 슬라이드 5: 실제 TV 예시 -->
    <div class="slide">
      <h2>실제 예시: TV 시청하기</h2>

      <div class="comparison">
        <div class="wrong">
          <h3>❌ 잘못된 방법 (양방향)</h3>
          <div class="code-block">
            TV.channel = 7; // 누가 언제 바꿨는지 모름
            SomeComponent.forceUpdate();
            // 어떤 컴포넌트가 영향받는지 모름
          </div>
        </div>
        <div class="correct">
          <h3>✅ Redux 방법 (단방향)</h3>
          <div class="code-block">
            dispatch(changeChannel(7))
            → tvReducer
            → store
            → 모든 연결된 컴포넌트 업데이트
          </div>
        </div>
      </div>

      <div class="quiz-box">
        <p style="font-size: 1.3em;">
          <strong>핵심:</strong> 데이터가 어디서 와서 어디로 가는지 <span class="highlight">추적 가능</span>!
        </p>
      </div>
    </div>

    <!-- 슬라이드 6: TV 리모컨 예제 -->
    <div class="slide">
      <h2>2️⃣ TV 리모컨 예제: 왜 이 비유가 완벽한가?</h2>

      <div class="comparison">
        <div style="text-align: center;">
          <h3>🏠 리모컨 사용의 현실</h3>
          <div class="vertical-flow">
            <div class="step-box">사용자</div>
            <div class="arrow">↓</div>
            <div class="step-box">리모컨 버튼</div>
            <div class="arrow">↓</div>
            <div class="step-box">TV 내부 회로</div>
            <div class="arrow">↓</div>
            <div class="step-box">화면 변경</div>
          </div>
        </div>
        <div style="text-align: center;">
          <h3>💻 Redux도 동일한 패턴</h3>
          <div class="vertical-flow">
            <div class="step-box">사용자</div>
            <div class="arrow">↓</div>
            <div class="step-box">Action</div>
            <div class="arrow">↓</div>
            <div class="step-box">Reducer</div>
            <div class="arrow">↓</div>
            <div class="step-box">컴포넌트 업데이트</div>
          </div>
        </div>
      </div>
    </div>

    <!-- 슬라이드 7: 왜 직접 손대면 안 되나 -->
    <div class="slide">
      <h2>❓ Why: 왜 TV에 직접 손대면 안 되나?</h2>

      <div class="comparison">
        <div class="wrong">
          <h3>❌ TV에 직접 손대기</h3>
          <div class="code-block">
            TV.내부회로.channel = 7;
            // 위험! TV 고장날 수 있음
          </div>
        </div>
        <div class="correct">
          <h3>✅ 리모컨 사용 (안전한 방법)</h3>
          <div class="code-block">
            리모컨.channelButton(7);
            // TV가 안전하게 처리
          </div>
        </div>
      </div>

      <h3>Redux도 마찬가지:</h3>
      <div class="comparison">
        <div class="wrong">
          <h3>❌ 상태에 직접 손대기 (금지!)</h3>
          <div class="code-block">
            state.channel = 7;
            // React가 변화를 못 감지
          </div>
        </div>
        <div class="correct">
          <h3>✅ Action을 통한 안전한 변경</h3>
          <div class="code-block">
            dispatch({
            type: 'CHANGE_CHANNEL',
            payload: 7
            });
          </div>
        </div>
      </div>
    </div>

    <!-- 슬라이드 8: 실제 TV 리모컨 코드 -->
    <div class="slide">
      <h2>실제 TV 리모컨 코드</h2>

      <div class="code-block">
        // TV 상태 (Store)
        const initialState = {
        power: false,
        channel: 1,
        volume: 10
        };

        // 리모컨 버튼 (Action)
        const pressChannelButton = (channelNumber) => ({
        type: 'CHANGE_CHANNEL',
        payload: channelNumber
        });

        // TV 내부 시스템 (Reducer)
        const tvReducer = (state = initialState, action) => {
        switch (action.type) {
        case 'CHANGE_CHANNEL':
        return {
        ...state, // 기존 설정 유지 (전원, 볼륨)
        channel: action.payload // 채널만 변경
        };
        default:
        return state; // 모르는 버튼이면 무시
        }
        };
      </div>

      <h3 style="margin-top: 20px;">Why 이 패턴?</h3>
      <ul style="text-align: left; margin-top: 15px;">
        <li><strong>안전성:</strong> TV 고장나지 않게 보호</li>
        <li><strong>예측성:</strong> 버튼 누르면 예상 가능한 결과</li>
        <li><strong>추적성:</strong> 누가 언제 어떤 버튼 눌렀는지 기록</li>
      </ul>
    </div>

    <!-- 슬라이드 9: 동기 vs 비동기 -->
    <div class="slide">
      <h2>3️⃣ 동기 vs 비동기: 왜 다르게 처리해야 하나?</h2>
      <h3>❓ Why: 일반 Redux는 비동기를 못 처리하나?</h3>

      <div class="comparison">
        <div class="correct">
          <h3>✅ 동기 처리 (일반 Redux)</h3>
          <div class="code-block">
            // 즉시 처리 가능한 작업
            const changeChannel = (channel) => ({
            type: 'CHANGE_CHANNEL',
            payload: channel // 바로 사용 가능한 데이터
            });

            // Reducer에서 즉시 처리
            case 'CHANGE_CHANNEL':
            return { ...state, channel: action.payload };
          </div>
        </div>
        <div class="wrong">
          <h3>❌ 비동기 처리의 문제</h3>
          <div class="code-block">
            // 이렇게 하면 안 됨!
            const fetchChannelInfo = (channel) => ({
            type: 'FETCH_CHANNEL_INFO',
            payload: fetch(`/api/channel/${channel}`)
            // Promise 객체! 데이터 아님!
            });

            // Reducer는 Promise를 처리할 수 없음
            case 'FETCH_CHANNEL_INFO':
            return { ...state, channelInfo: action.payload };
            // Promise 객체가 저장됨 🚨
          </div>
        </div>
      </div>
    </div>

    <!-- 슬라이드 10: 비동기 3단계 -->
    <div class="slide">
      <h2>Why 비동기 처리가 복잡한가?</h2>
      <h3>비동기 작업의 3단계</h3>

      <div class="three-stage">
        <div class="stage-box" style="background: rgba(255,193,7,0.3);">
          <h4>1. 로딩 시작</h4>
          <p>"채널 정보 가져오는 중..."</p>
        </div>
        <div class="stage-box" style="background: rgba(33,150,243,0.3);">
          <h4>2. 로딩 중...</h4>
          <p>스피너 표시</p>
        </div>
        <div class="stage-box" style="background: rgba(76,175,80,0.3);">
          <h4>3. 완료/실패</h4>
          <p>데이터 표시 또는 에러 표시</p>
        </div>
      </div>

      <h3>Redux에서 3개 Action 필요</h3>
      <div class="code-block">
        // 1. 로딩 시작
        { type: 'FETCH_CHANNEL_START' }

        // 2. 성공
        { type: 'FETCH_CHANNEL_SUCCESS', payload: channelData }

        // 3. 실패
        { type: 'FETCH_CHANNEL_ERROR', payload: errorMessage }
      </div>
    </div>

    <!-- 슬라이드 11: Redux Thunk -->
    <div class="slide">
      <h2>Redux Thunk: 비동기 해결책</h2>
      <h3>❓ Why Thunk가 필요한가?</h3>

      <div class="comparison">
        <div class="wrong">
          <h3>❌ 일반 Action Creator (동기만)</h3>
          <div class="code-block">
            const normalAction = () => ({
            type: 'SOME_ACTION' // 객체만 반환 가능
            });
          </div>
        </div>
        <div class="correct">
          <h3>✅ Thunk Action Creator (비동기 가능)</h3>
          <div class="code-block">
            const thunkAction = () => {
            return async (dispatch, getState) => { // 함수 반환!
            dispatch({ type: 'LOADING_START' });

            try {
            const data = await fetch('/api/data');
            dispatch({ type: 'SUCCESS', payload: data });
            } catch (error) {
            dispatch({ type: 'ERROR', payload: error.message });
            }
            };
            };
          </div>
        </div>
      </div>
    </div>

    <!-- 슬라이드 10: 실제 TV 예제 비동기 -->
    <div class="slide">
      <h2>실제 TV 예제: 채널 정보 가져오기</h2>

      <div class="code-block">
        // 동기: 채널 바꾸기 (즉시 가능)
        const changeChannel = (channel) => ({
        type: 'CHANGE_CHANNEL',
        payload: channel
        });

        // 비동기: 채널 정보 가져오기 (시간 필요)
        const fetchChannelInfo = (channel) => {
        return async (dispatch) => {
        // 1단계: 로딩 시작
        dispatch({
        type: 'FETCH_CHANNEL_INFO_START',
        payload: { channel, loading: true }
        });

        try {
        // 2단계: API 호출 (시간 걸림)
        const response = await fetch(`/api/channel/${channel}`);
        const channelInfo = await response.json();

        // 3단계: 성공
        dispatch({
        type: 'FETCH_CHANNEL_INFO_SUCCESS',
        payload: { channel, channelInfo, loading: false }
        });
        } catch (error) {
        // 3단계: 실패
        dispatch({
        type: 'FETCH_CHANNEL_INFO_ERROR',
        payload: { channel, error: error.message, loading: false }
        });
        }
        };
        };
      </div>
    </div>

    <!-- 슬라이드 12: 왜 복잡하게? -->
    <div class="slide">
      <h2>4️⃣ 왜 이렇게 복잡하게 해야 하나?</h2>
      <h3>❓ Why: 간단한 상태 변경도 이렇게 많은 단계를?</h3>

      <div class="quiz-box">
        <h4>복잡함의 이유</h4>
        <div class="code-block">
          // 단순해 보이지만...
          dispatch(changeChannel(7));

          // 실제로는 이 모든 과정이 일어남
          Action 생성 → Dispatch → Reducer 실행 → Store 업데이트 →
          Component 리렌더링 → DevTools 기록 → Middleware 처리...
        </div>
      </div>

      <h3>🚦 Redux = 교통 신호등 시스템</h3>
      <div class="comparison">
        <div class="wrong">
          <h3>❌ 신호등 없는 교차로</h3>
          <div class="big-emoji">🚗💥🚕</div>
          <ul>
            <li>빠르긴 하지만 위험</li>
            <li>누구 책임인지 모름</li>
          </ul>
        </div>
        <div class="correct">
          <h3>✅ 신호등 있는 교차로</h3>
          <div class="big-emoji">🚗🟢🔴🚕</div>
          <ul>
            <li>복잡하지만 안전</li>
            <li>규칙이 명확함</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- 슬라이드 12: 그럼에도 이렇게 하는 이유 -->
    <div class="slide">
      <h2>그럼에도 이렇게 하는 이유</h2>

      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin: 30px 0;">
        <div class="flow-box">
          <h3>🎯 1. 예측 가능성</h3>
          <div class="code-block">
            // Redux: 항상 같은 결과
            dispatch(changeChannel(7));
            // 100% 확실히 채널 7로 변경

            // 직접 변경: 예측 불가
            state.channel = 7;
            // 다른 코드가 방해할 수도?
          </div>
        </div>
        <div class="flow-box">
          <h3>🔍 2. 디버깅 용이성</h3>
          <div class="code-block">
            // Redux DevTools에서 확인 가능
            Action: { type: 'CHANGE_CHANNEL', payload: 7 }
            이전 상태: { channel: 5 }
            다음 상태: { channel: 7 }
            시간: 2024-01-01 10:30:15
          </div>
        </div>
        <div class="flow-box">
          <h3>⏰ 3. 시간 여행 디버깅</h3>
          <div class="code-block">
            // "3분 전 상태로 돌아가고 싶어"
            Redux DevTools에서 클릭 한 번이면 끝!
          </div>
        </div>
        <div class="flow-box">
          <h3>👥 4. 협업 안전성</h3>
          <div class="code-block">
            // 개발자 A가 실수해도
            state.channel = undefined; // ❌ 다른 개발자 코드 망가뜨림

            // Redux는 안전
            dispatch(badAction()); // ✅ Reducer에서 검증 후 처리
          </div>
        </div>
      </div>
    </div>

    <!-- 슬라이드 14: 결론 - Redux를 쓰는 진짜 이유 -->
    <div class="slide">
      <h2>5️⃣ 결론: Redux를 쓰는 진짜 이유</h2>

      <div class="comparison">
        <div class="correct">
          <h3>✅ Redux를 써야 하는 경우</h3>
          <ul>
            <li>복잡한 앱 (컴포넌트 20개 이상)</li>
            <li>여러 개발자 협업 (규칙 필요)</li>
            <li>상태 추적 중요 (금융, 의료 등)</li>
            <li>디버깅 중요 (버그 찾기 어려운 앱)</li>
          </ul>
        </div>
        <div class="wrong">
          <h3>❌ Redux 안 써도 되는 경우</h3>
          <ul>
            <li>간단한 앱 (TodoList 수준)</li>
            <li>혼자 개발 (규칙 덜 중요)</li>
            <li>프로토타입 (빠른 개발 우선)</li>
          </ul>
        </div>
      </div>

      <div class="quiz-box" style="margin-top: 30px;">
        <p style="font-size: 1.3em;">
          <strong>Redux = 복잡하지만 안전하고 예측 가능한 상태 관리 시스템!</strong>
        </p>
      </div>
    </div>

    <!-- 슬라이드 15: 핵심 정리 -->
    <div class="slide">
      <h2>6️⃣ 핵심 정리</h2>

      <div style="text-align: left; max-width: 800px;">
        <h3 style="color: #FFD700; margin-bottom: 20px;">Why Redux?</h3>
        <ul>
          <li>예측 가능한 상태 관리</li>
          <li>체계적인 데이터 플로우</li>
          <li>강력한 디버깅 도구</li>
          <li>협업 안전성</li>
        </ul>

        <h3 style="color: #87CEEB; margin: 30px 0 20px 0;">Why 이렇게 복잡하게?</h3>
        <ul>
          <li>안전성 > 편의성</li>
          <li>장기적 유지보수성</li>
          <li>팀 협업 효율성</li>
        </ul>

        <h3 style="color: #FFB6C1; margin: 30px 0 20px 0;">Why 비동기 처리가 다른가?</h3>
        <ul>
          <li>3단계 상태 관리 필요 (로딩/성공/실패)</li>
          <li>순수 함수 원칙 유지</li>
          <li>예외 상황 대응</li>
        </ul>
      </div>
    </div>

    <!-- 슬라이드 16: 마무리 Q&A -->
    <div class="slide">
      <h1>🙋‍♀️ Q&A</h1>

      <div style="font-size: 1.4em; margin: 30px 0;">
        <p><strong>"왜 이렇게 해야 하는지"</strong></p>
        <p>이제 이해하셨나요?</p>
      </div>

      <div class="big-emoji">🎯✨🚀</div>

      <p style="font-size: 1.2em; margin-top: 30px; color: #87CEEB;">
        복잡함의 대가로 얻는 것:<br />
        <span class="highlight">안전성, 예측성, 유지보수성!</span>
      </p>

      <div style="margin-top: 40px; font-size: 1.1em; opacity: 0.9;">
        <p>궁금한 점 있으시면 언제든 물어보세요!</p>
      </div>
    </div>

    <!-- 네비게이션 -->
    <div class="navigation">
      <button class="nav-btn" id="prevBtn" onclick="changeSlide(-1)">◀ 이전</button>
      <div class="slide-counter">
        <span id="currentSlide">1</span> / <span id="totalSlides">16</span>
      </div>
      <button class="nav-btn" id="nextBtn" onclick="changeSlide(1)">다음 ▶</button>
    </div>
  </div>

  <script>
    let currentSlideIndex = 0;
    const slides = document.querySelectorAll('.slide');
    const totalSlides = slides.length;

    document.getElementById('totalSlides').textContent = totalSlides;

    function showSlide(index) {
      slides.forEach(slide => slide.classList.remove('active'));
      slides[index].classList.add('active');

      document.getElementById('currentSlide').textContent = index + 1;
      document.getElementById('prevBtn').disabled = index === 0;
      document.getElementById('nextBtn').disabled = index === totalSlides - 1;
    }

    function changeSlide(direction) {
      currentSlideIndex += direction;
      if (currentSlideIndex < 0) currentSlideIndex = 0;
      if (currentSlideIndex >= totalSlides) currentSlideIndex = totalSlides - 1;
      showSlide(currentSlideIndex);
    }

    // 키보드 네비게이션
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') changeSlide(-1);
      if (e.key === 'ArrowRight') changeSlide(1);
    });

    // 초기 설정
    showSlide(0);
  </script>
</body>

</html>